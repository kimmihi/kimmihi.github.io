{"pageProps":{"matterPostList":["---\nid: code-review\ntitle: 1년동안 코드리뷰를 하면서 느낀점\ndate: 2023-05-21\ncategory: essay\nthumb_nail: /blog/images/code-review/thumb_nail.png\nsummary: 2022년 1월에 첫 회사에서 프론트엔드 개발을 시작하면서 지금까지 많은 것을 배웠다. 그 중 하나는 왜 코드리뷰를 해야 하는지, 어떻게 코드리뷰를 해야 하는지를 배운 것이다. 사실 취업 준비를 할 때 프로젝트를 같이하는 사람들끼리 코드리뷰를 진행하기도 했었다. 하지만 그 때는 정해진 규칙도 없고 무엇을 리뷰해야하는 지도 잘 알지 못했기 때문에 효과를 보지 못했다. 그래서 나의 경험을 공유하여 아직 코드리뷰를 하지 않는 팀에게 코드리뷰를 도입할 수 있도록 도움을 주고싶다.\n---\n\n# 1년동안 코드리뷰를 하면서 느낀점\n\n## Intro\n\n2022년 1월에 첫 회사에서 프론트엔드 개발을 시작하면서 지금까지 많은 것을 배웠다. 그 중 하나는 왜 코드리뷰를 해야 하는지, 어떻게 코드리뷰를 해야 하는지를 배운 것이다. 사실 취업 준비를 할 때 프로젝트를 같이하는 사람들끼리 코드리뷰를 진행하기도 했었다. 하지만 그 때는 정해진 규칙도 없고 무엇을 리뷰해야하는 지도 잘 알지 못했기 때문에 효과를 보지 못했다. 그래서 나의 경험을 공유하여 아직 코드리뷰를 하지 않는 팀에게 코드리뷰를 도입할 수 있도록 도움을 주고싶다.\n\n## 왜 코드리뷰를 해야할까?\n\n1년 동안 코드리뷰를 진행하면서 크게 2가지 측면에서 필요성을 느꼈다.\n\n### 1. 팀원의 부재\n\n규모가 작은 팀일수록 각각의 팀원의 역할이 매우 중요하다. 만약 개발자 한 명이 하나의 프로젝트 전체를 맡고 있다면 이 개발자가 부재 중일 때는 프로젝트의 진도가 나가지 못할 것이고 에러에 쉽게 대응할 수 없을 것이다. 또는 여러 명의 개발자가 하나의 프로젝트를 맡고 있다고 하더라도 소통 없이 본인의 코드만 신경 쓴다면 다른 개발자가 부재 중일 때 그 개발자의 코드를 파악하여 대응하는 데 오랜 시간이 걸릴 것이다. 이처럼 프로젝트마다 개발자 한 명의 의존도가 높다면 프로젝트가 위험해질 수 있다.\n\n하지만 코드 리뷰를 진행했다면 다른 개발자가 작성한 코드를 미리 파악하고 있기 때문에 대응하는데 그리 오랜 시간이 걸리지 않을 것이며 팀원이 부재중이더라도 프로젝트의 개발은 계속해서 평소와 다를 것 없이 진행될 것이다.\n\n### 2. 개인의 성장\n\n대부분의 개발자들은 꾸준히 공부를 한다. 특히, 주니어 개발자 입장에서는 아직 모르는 것이 많고 새로운 기술들이 빠르게 나오기 때문에 꾸준히 공부할 수밖에 없다. 하지만 자는 시간과 회사에서 일을 하는 시간을 빼면 개개인의 차이가 있겠지만 3~5시간 정도를 오로지 개인 공부를 위해 투자할 수 있다.\n\n하지만 회사에서도 개인의 성장을 위한 시간을 만들 수 있다. 경험상 그중 하나는 코드 리뷰를 하는 시간이었다. 나는 6개월 동안 하나의 프로덕트에 2명의 팀원과 일을 한 적이 있다. 시간에 비해 개발해야 할 양이 많았지만 반드시 PR(Pull Request)를 한 후에 2명의 팀원에게 코드 리뷰를 받고 머지를 하도록 정했다.\n\n사실 개발할 시간도 적은데 코드 리뷰까지 하려고 하니 힘들었던 적도 있었다. 하지만 코드 리뷰를 하면서 다음과 같은 것들을 배웠다.\n\n- 코드의 가독성을 높이기 위해 고민한 시간\n- 다른 사람의 코드를 파악하는 역량\n- 기존에 사용하고 있던 라이브러리 중 알지 못했던 내용들\n- 팀원들과 더 좋은 코드를 위한 토론의 시간\n\n이처럼 코드 리뷰를 하는 동안에도 개인적으로 성장의 시간이었다. 그렇기 때문에 지금까지도 반드시 코드 리뷰를 하고 있고, 아직도 많은 것을 배우고 있다.\n\n## 효과적인 코드리뷰 방법\n\n코드 리뷰의 효과를 얻기 위해서는 체계적인 접근이 필요하다. 코드 리뷰를 도입한 초기에 많은 시행착오를 겪었지만 경험이 쌓일수록 팀 전체적으로 효과를 얻기 위한 방법과 규칙을 정하였다. 다음은 다른 사람의 코드를 리뷰할 때와 본인이 코드 리뷰를 요청할 때로 나눠서 규칙과 방법을 정리한 것이다.\n\n### 리뷰를 할 때\n\n1. 본인 만의 루틴 만들기\n\n리뷰 경험이 많지 않은 초창기에는 어디서부터 무엇을 리뷰해야 할지 막막하기만 하다. 그래서 리뷰할 때 체크 리스트를 만들어 습관이 될 때까지 지키는 것이 좋다. 예를 들면 다음과 같다.\n\n- 변경 사항에서 오타 확인하기\n- 컨벤션과 다른 코드가 있는지 확인하기\n- 기능이 정상적으로 동작하는지 확인하기\n- 불필요한 연산은 없는지 확인하기\n\n위에서 제시한 4개의 항목처럼 리뷰를 할 때마다 체크 리스트를 보면서 리뷰를 한다면 조금 더 꼼꼼히 리뷰를 하게 되고, 팀원들에게 더 도움이 된다. 개인적으로는 오타를 확인하거나 기능이 정상적으로 동작하는지 확인하는 등의 큰 그림을 본 이후에 성능을 최적화하는 등의 세세한 부분으로 파악하는 편이다.\n\n1. 본인이라면 어떻게 했을지 생각하기\n\n리뷰를 할 때 핵심이 되는 로직들이 있다. 그러한 로직들을 보고 나라면 어떻게 했을지 생각해 보는 것이다. 이렇게 했을 때 2가지 장점을 얻을 수 있다.\n\n첫 번째는 전체적인 코드 파악이 빠르다. 내가 작업할 때는 많은 고민을 하고 시간을 들여서 하기 때문에 시간이 지나더라도 쉽게 파악이 가능하다. 하지만 다른 사람이 작업한 내용은 리뷰를 할 때 한 것이 전부일 수 있다. 그렇기 때문에 리뷰 시간에 내가 작업한다면 어떻게 했을까를 시작으로 설계를 해보는 것이다. 작업한 사람만큼의 고민과 시간이 들어갈 수는 없어도 최소한 시간이 지나더라도 쉽게 파악할 수 있고, 이것이 쌓이면 전체적인 코드를 수월하게 파악할 수 있게 된다.\n\n두 번째는 더욱더 책임감을 느낄 수 있다는 것이다. 하나의 소프트웨어는 수많은 코드로 이루어진다. 그중에 본인의 코드는 극히 일부분일 수 있다. 이때 자칫 본인이 작성한 코드에만 문제가 없으면 안심하는 등의 무책임한 태도가 생길 수 있다. 하지만 다른 사람의 코드를 보며 본인이라면 어떻게 할지 생각한다면 점점 주인의식이 생기는 코드 분량이 많아진다는 느낌이 들고 책임감을 느낄 수 있다. 책임감을 느끼면 제품에 애착을 갖고 본인이 더 좋은 코드를 위해 노력하는 선순환이 될 것이다.\n\n### 리뷰를 요청할 때\n\n1. 적당한 크기로 분할하기\n\n본인의 시간뿐만 아니라 팀원들의 시간도 소중하다. 만약 본인이 다른 팀원의 코드를 리뷰해야 하는데 리뷰해야 할 코드가 3,000줄이 된다면 어떤 기분이 들지 상상해 보자. 본인이 해야 할 작업도 많고 시간도 촉박한데 3,000줄의 코드를 파악해야 하니 시작하기도 전에 지칠 것이다.\n\n또한 코드의 양이 많다 보니 코드 파악하는 시간도 오래 걸리고 꼼꼼한 리뷰가 진행될 확률이 적어진다. 따라서 팀원들의 시간도 절약하고 본인도 더 효과적인 리뷰를 받기 위해서는 적당한 크기로 작업을 나누어 리뷰를 받는 것이다. 작업을 나누기 애매했을 때는 commit을 분할하여 PR을 올릴 수도 있을 것이다.\n\n1. 본인이 작업한 내용 정리하기\n\n팀원이 리뷰를 올렸을 때 추가적인 설명 없이 리뷰를 요청한다면 어떤 생각이 들까? 대체 어떤 작업을 한 것이지? 이렇게 설계한 기준이 뭐지? 등 다양한 궁금점이 있을 것이다. 그렇기 때문에 리뷰를 요청할 때는 본인이 작업한 내용을 가독성 있게 정리하는 것이 중요하다.\n\n현재 작업에 대한 배경지식을 제공하고 작업하면서 고민이 되었던 부분은 무엇이며 다른 팀원들의 의견을 요청할 수도 있을 것이다. 이러한 내용이 PR에 포함된다면 불필요한 커뮤니케이션을 줄여 시간을 절약할 수 있다.\n\n## 마무리\n\n각자 코드 리뷰를 경험하면서 느끼는 장단점이 다를 수 있다. 하지만 개인적으로 코드 리뷰를 하면서 느낀 단점보다는 장점이 훨씬 크게 작용하기 때문에 반드시 해야 한다는 생각을 갖고 있다. 그리고 이렇게 느끼게 된 경험과 근거를 이번 글에 정리를 해봤다.\n\n아직 코드 리뷰를 시작하지 않았거나 하는 둥 마는 둥 하는 팀이 있다면 이 글이 도움이 되었으면 좋겠다.\n","---\nid: javascript-runtime\ntitle: 브라우저는 자바스크립트를 어떻게 실행시킬까?\ndate: 2023-04-02\ncategory: javascript\nthumb_nail: /blog/images/javascript-runtime/thumb_nail.png\nsummary: 프로그래밍 언어를 공부할 때 그 언어가 어떻게 실행되고, 어디에 주로 쓰이는지 등과 같은 특성을 아는 것은 언어를 깊이 이해하는 데에 도움이 된다고 생각한다. 그래서 이번에 자바스크립트의 런타임 환경에 대해 정리를 하였다. 자바스크립트는 크롬, 엣지, 사파리와 같은 웹 브라우저에서 실행되는데 각각의 웹 브라우저에는 자바스크립트를 실행시키기 위한 엔진이 존재한다. 그 중에서 크롬의 자바스크립트 엔진인 V8을 기준으로 정리하려고 한다. 왜냐하면 크롬이라는 웹 브라우저를 가장 많이 사용하기도 하지만 자바스크립트를 서버 사이드에서 사용할 수 있도록 Node.js에서 V8 엔진을 사용하고 있기 때문이다. 이 글에는 자바스크립트가 어떤 과정과 방법을 통해 실행이되는지 알아보고, 이를 통해 실제 자바스크립트로 좋은 코드를 작성하기 위해서는 어떻게 할 수 있을지 아이디어를 얻어보고자 한다.\n---\n\n# 브라우저는 자바스크립트를 어떻게 실행시킬까?\n\n## Intro\n\n프로그래밍 언어를 공부할 때 그 언어가 어떻게 실행되고, 어디에 주로 쓰이는지 등과 같은 특성을 아는 것은 언어를 깊이 이해하는 데에 도움이 된다고 생각한다. 그래서 이번에 자바스크립트의 런타임 환경에 대해 정리를 하였다.\n\n자바스크립트는 크롬, 엣지, 사파리와 같은 웹 브라우저에서 실행되는데 각각의 웹 브라우저에는 자바스크립트를 실행시키기 위한 엔진이 존재한다. 그 중에서 크롬의 자바스크립트 엔진인 V8을 기준으로 정리하려고 한다. 왜냐하면 크롬이라는 웹 브라우저를 가장 많이 사용하기도 하지만 자바스크립트를 서버 사이드에서 사용할 수 있도록 Node.js에서 V8 엔진을 사용하고 있기 때문이다.\n\n이 글에는 자바스크립트가 어떤 과정과 방법을 통해 실행이되는지 알아보고, 이를 통해 실제 자바스크립트로 좋은 코드를 작성하기 위해서는 어떻게 할 수 있을지 아이디어를 얻어보고자 한다.\n\n## Javascript가 실행되는 환경\n\n브라우저에서 자바스크립트를 어떻게 실행시키는지 알기 위해서는 런타임 환경이라는 단어의 의미를 간단히 알아둘 필요가 있다. 런타임 환경은 어떤 프로그래밍 언어가 실행되는 환경을 의미한다. 자바스크립트의 런타임 환경은 주로 브라우저이며 브라우저의 자바스크립트 엔진을 통해 자바스크립트 코드가 실행된다. 또한, Chrome의 자바스크립트 엔진인 V8으로 빌드된 Node.js를 활용하면 서버 측에서도 자바스크립트 코드를 실행시킬 수 있다.\n\n## Chrome의 자바스크립트 엔진 : V8\n\nChrome의 V8은 구글에서 개발한 자바스크립트 엔진이며 Node.js에서도 이 엔진을 사용하여 서버 측에서도 자바스크립트를 실행시킬 수 있게 되었다. 아래의 그림은 V8이 어떻게 자바스크립트 코드를 해석하여 실행시키는지 파악할 수 있는 흐름을 나타내고 있다.\n\n![v8.png](/blog/images/javascript-runtime/v8.png)\n\n각각의 단계에서 어떤 일들이 발생하는지 알아보자.\n\n### 1. 구문 분석 (Parsing)\n\n먼저 자바스크립트 코드는 Parser를 통해 토큰으로 분해되고 이를 추상 구문 트리(AST)로 변환한다. 추상 구문 트리는 소스 코드를 계층적으로 분해하여 인터프리터가 읽어드리기 쉽게 해준다. 예를 들어 아래의 두 개의 숫자를 전달받아 더한 값을 반환하는 함수와 그 함수를 실행시키는 코드가 있다고 해보자.\n\n```javascript\nfunction sum(a, b) {\n  return a + b;\n}\n\nsum(3, 5);\n```\n\n위의 코드를 추상 구문 트리로 변환하면 아래와 비슷한 형태로 변환될 것이다.\n\n```scss\nProgram\n└─ FunctionDeclaration (sum)\n   ├─ Identifier (a)\n   ├─ Identifier (b)\n   └─ BinaryExpression (+)\n      ├─ Identifier (a)\n      └─ Identifier (b)\n```\n\n그런데 왜 추상 구문 트리로 변환하는 것일까? 여기에는 다양한 이유가 있지만 크게 3가지 이유는 다음과 같다.\n\n1. 기계어로 컴파일 하기 전에 코드를 분석하고 최적화할 수 있는 부분을 미리 찾아낼 수 있다.\n2. 코드를 직관적으로 표현하기 때문에 잠재적인 보안 취약점을 식별하고 예방할 수 있다.\n3. 자바스크립트 코드를 바이트 코드로 변환하는 것보다 추상 구문 트리를 바이트 코드로 변환하는 것이 더 빠르다.\n\n### 2. 인터프리터 : Ignition\n\n자바스크립트는 인터프리터에 의해 실행된다. 인터프리터는 소스 코드를 한줄 한줄 해석한 후에 실행시키는 프로그램을 의미한다. 반면에 컴파일러는 실행시키기 전에 소스 코드를 해석하여 실행할 수 있는 파일을 만들어내는 프로그램이다.\n\nV8 엔진은 Ignition이라는 인터프리터를 사용한다. Ignition은 Parser에 의해 생성된 추상 구문 트리를 해석하여 컴퓨터에 명령을 내릴 수 있는 바이트 코드를 생성한다.\n\n### 3. 최적화 : Turbofan\n\n인터프리터를 사용하는 언어는 컴파일러를 사용하는 언어보다 실행속도가 느리다는 단점이 있다. 미리 기계 코드로 변환된 것을 실행시키는 컴파일러 언어보다 매번 소스 코드를 해석하고 실행시키기 때문이다. 하지만 V8 엔진에는 이러한 단점을 보완하는 Turbofan이라는 컴포넌트가 존재한다. 이번에는 Turbofan이 인터프리터 언어의 단점을 보완하기 위해 최적화하는 방법 3가지를 알아보려고 한다.\n\n1. **인라이닝**\n\n인라이닝에 대해 알아보기 전에 함수를 호출할 때 무슨 일이 발생하는지 간단하게 알아둘 필요가 있다. 함수를 호출하면 함수가 실행이 완료되고 다시 함수를 호출한 위치로 돌아가기 위한 주소를 저장한다. 그리고 함수가 콜 스택에 추가되어 실행을 기다린다. 이렇게 함수의 호출에는 비용이 발생한다. 이러한 비용을 줄이기 위해 인라이닝을 사용할 수 있다.\n\nC/C++ 언어에는 인라인 함수가 존재한다. 함수를 호출하는 대신에 함수의 로직을 함수를 호출한 부분에 삽입시키는 것이다. 아래의 코드를 보자. **min** 함수는 두 개의 숫자를 전달받아 작은 수를 반환하는 함수이다. 이를 반복문을 통해 1000번 호출하고 있다. 함수를 호출할 때마다 오버헤드가 발생할 것 같지만 **inline** 이라는 키워드를 통해 생성된 인라인 함수는 주석에 표시한 것처럼 함수 안의 로직이 함수를 호출한 부분에 삽입되어 오버헤드가 발생하지 않는다.\n\n```cpp\ninline int min(int a, int b) {\n\treturn a <= b ? a : b;\n}\n\nvoid main() {\n\tint x = 5;\n\n\tfor (int i = 0; i < 1000; i++) {\n\t\tint min_num = (x, i); // int min_num = x <= i ? : x : i;\n\t\tprintf(\"%d\", min_num);\n\t}\n\n}\n```\n\n이처럼 Turbofan에서도 인라이닝을 통해 코드를 최적화하고 있다. 하지만 모든 함수에 대해 인라이닝을 적용하는 것은 아니다. 함수의 로직을 함수를 호출한 모든 부분에 삽입한다면 코드가 길어지고 메모리를 많이 사용하게 된다. 따라서 간단하고 적은 코드를 포함한 함수에 대해서만 인라이닝을 적용한다.\n\n1. **히든 클래스**\n\n자밥스크립트는 동적인 언어다. 실행 중에도 객체에 속성을 추가, 수정, 삭제를 할 수 있다. 이렇게 객체의 속성을 변경하기 위해서는 이미 존재하는 속성인지, 삭제하려는 속성은 무엇인지 탐색해야한다. 정적인 언어의 경우에는 컴파일 과정을 통해 미리 객체 안의 속성에 대한 오프셋을 알고있어 객체의 속성에 접근하는 것에 대한 오버헤드가 적다.\n\nTurbofan에서는 히든 클래스를 통해 동적인 언어에 대한 단점을 보완하고 있다. 아래의 코드를 보자. **person** 이라는 객체를 생성하면 C01이라는 히든 클래스가 생성된다.\n\n```javascript\nconst person = {}; // C01이라는 히든 클래스 생성\n```\n\n그 다음 **person** 객체에 **name** 이라는 속성을 추가하면 **name** 이라는 속성에 대한 오프셋을 저장하는 C02라는 히든 클래스를 생성한다. 이때 C01이라는 히든 클래스에는 **name** 이라는 속성을 추가하면 C02 히든 클래스로 전환된다는 정보가 추가된다.\n\n```javascript\nperson.name = \"Alex\"; // C02이라는 히든 클래스 생성 { offset 0 : name }\n```\n\n여기서 **animal** 이라는 빈 객체를 생성하면 히든 클래스 C01을 가리킨다. 하지만 **animal** 에 **age** 라는 속성을 추가하면 이전에 생성한 히든 클래스 C02를 사용하지 않고 새로운 히든 클래스를 생성하게 된다.\n\n1. **인라인 캐싱**\n\n위에서 알아본 히든 클래스를 기반으로 인라인 캐싱이라는 최적화 기법이 사용된다. 객체의 속성에 접근할 때 오프셋을 캐싱하여 사용하겠다는 것이다. 아래의 코드를 보자. `name` 속성을 갖는 똑같은 구조의 객체가 있다. 해당 속성에 접근을 할 때 처음에는 캐싱된 값이 없기 때문에 히든 클래스와 오프셋 값을 찾아서 저장한다. 이후에 속성 접근을 할 때는 캐싱된 값을 사용하여 더 빠르게 접근할 수 있게된다.\n\n```javascript\nconst a = { name: \"a\" };\nconst b = { name: \"b\" };\nconst c = { name: \"c\" };\nconst d = { name: \"d\" };\n\nconst alphabet = [a, b, c, d];\n\nfor (let i = 0; i < alphabet.length; i++) {\n  console.log(alphabet[i].name);\n}\n```\n\n## 조금 더 나은 코드를 위해서 적용할 수 있는 방법\n\n지금까지 V8 엔진에 대해서 알아봤다. 특히 Turbofan에서는 자바스크립트의 성능을 위해서 다양한 최적화 기법을 적용시켰는데 이를 이해하면 우리는 조금 더 성능이 좋은 코드를 작성할 수 있다. (개인적인 생각으로 틀린 내용이 있을 수 있습니다.)\n\n첫 번째 방법은 객체의 속성을 동적으로 변경하지 않는 것이다. 특히, 반복문 내에서 객체의 속성을 추가/수정/변경을 하면 히든 클래스를 활용하지 못하여 속성을 탐색하는데 비효율적이다. 따라서 반복문 외부에서 객체를 정의한 후에 사용해야 한다.\n\n두 번째 방법은 함수의 크기를 최소화하는 것이다. 작은 함수에 대해서 인라이닝을 적용하고 함수를 실행하는데 오버헤드가 적기 때문이다. 또한 함수의 크기를 최소화하는 것은 코드의 가독성을 높이고 하나의 함수를 한 가지 기능만을 하도록 만들 수 있다.\n\n세 번째 방법은 함수를 재사용하는 것이다. 본문에서 언급하지는 않았지만 Turbofan은 자주 사용하는 코드를 기계 코드로 변환하여 실행한다. 아무래도 바이트 코드보다 기계 코드를 실행하는 것이 빠르다. 따라서 동일한 로직이 여러 번 사용된다면 함수를 만들어 사용하는 것이 효율적인 것 같다.\n\n## 마무리\n\n저번에 회사의 시니어 개발자와 대화를 나누다가 주니어 때는 한 가지 기술을 파고들되 다양한 경험을 얕게 해보는 것이 중요하다는 얘기를 들었다. 이를 간단히 T자형으로 성장한다고 말한다. 그러면서 현재 쓰고있는 기술 중에 스스로 잘 안다고 자신있게 말할 수 있는 것이 있을까?라는 생각을 했고 “없다”라는 결론이 나왔다.\n\n그래서 자바스크립트에 대해 조금 더 깊게 공부를 해야되겠다는 생각을 하였고, 가장 먼저 자바스크립트가 어떻게 실행되는지 공부하고 정리를 하였다. 이에 대해 몰랐을 때보다 알고난 후에(모든 것을 아는 것은 아니지만) 자바스크립트에 대해 더 관심이 생겼고 코드를 작성할 때 “그냥” 작성하는 경우가 줄었다. 그래서 앞으로도 자바스크립트에 대해 조금 더 깊은 내용들을 공부하고 정리하려고 한다.\n","---\nid: window-open\ntitle: window.open을 사용할 때 알아두면 좋은 점\ndate: 2023-04-20\ncategory: javascript\nthumb_nail: /blog/images/window-open/test2.png\nsummary: 여러 개의 창을 열어 모니터링을 할 수 있도록 window.open을 사용하였다. 이때 몇 가지 문제가 있다는 것을 발견하였고 이를 해결하기 위한 방법을 정리하였다.\n---\n\n# window.open을 사용할 때 알아두면 좋은 점\n\n## Intro\n\n**window.open**을 사용하면 해당 메서드를 호출한 페이지에서 새로운 창 또는 탭이 열리도록 할 수 있다. 최근에 모니터링 관련 기능을 개발하면서 새로운 창을 100개 이상 열어야했고, 새로운 창에서는 WebSocket을 통한 통신이 이루어졌다. 이때 100개 이상 열었을 때 성능에는 문제가 없는지 궁금해서 테스트를 해봤고 새로운 사실을 알 수 있었다. 그래서 이번에 **window.open**을 사용할 때 알아두면 좋은 점을 정리해보려고 한다.\n\n## window.open()은 어떻게 사용할까?\n\nwindow.open()은 다음 예시 코드처럼 간단하게 사용할 수 있으며 3개의 파라미터를 전달할 수 있다. 첫 번째 파라미터에 URL을 전달하면 해당 URL이 새 탭으로 열리게 된다.\n\n```jsx\nconst handleClick = () => {\n  window.open(\"https://www.google.com\");\n};\n```\n\n또한 두 번째 파라미터인 target을 통해 새 창이 열릴 위치를 지정할 수 있다.\n\n- \\_blank : 링크가 새 창에서 열린다.\n- \\_self : 링크가 현재 창에서 열린다.\n- \\_parent : 링크가 부모 창에서 열린다.\n- \\_top : 링크가 최상위 창에서 열린다.\n\n마지막으로 세 번째 파라미터에는 스타일 등의 속성을 문자열로 전달할 수 있다.\n\n## window.open()을 사용할 때 주의할 점\n\n먼저 첫 번째로 **Tabnabbing** 공격을 방어해야 한다. Tabnabbing 공격은 다음 순서로 진행된다.\n\n1. A라는 페이지에 접속\n2. 해당 페이지에서 새로운 페이지로 이동할 수 있는 외부링크 클릭\n3. 새로운 페이지에서 기존 A페이지를 가리키는 opener로 기존 A페이지를 다른 페이지로 유도\n4. A페이지에 돌아왔을 때 사용자가 입력한 정보에 대해 피싱\n\n하지만 위의 문제는 2016년부터 크롬에서 window.open()을 \\_blank로 열 때, 새 페이지에서 opener를 갖지못하도록 속성이 설정되어있어서 방어가 가능하다.\n\n두 번째 문제는 이 글을 쓰는 이유에 있는데 **같은 도메인의 다른 페이지를 새 창으로 열었을 때, 새 창과 부모 창의 메모리와 자원이 공유된다는 것이다.** 그렇기 때문에 부모 창과 새 창에서 높은 수준의 연산이 필요한 작업을 한다면 성능이 떨어질 수 있다.\n\n이를 알아보기 위한 간단한 테스트를 준비했다. 페이지 내에서 10ms마다 랜덤한 숫자를 출력한다. 그리고 새롭게 열린 창에서도 10ms마다 랜덤한 숫자를 출력하도록 하였다. 이를 크롬의 Performance로 측정하였다.\n\n먼저 아래의 사진은 새 창을 열지 않았을 때의 결과이다. 약 4초 동안 Javascript 연산을 실행하는데 극히 적은 시간을 사용했다.\n\n![test1.png](/blog/images/window-open/test1.png)\n\n반면 아래의 결과는 새로운 창 10개를 열고 부모 창에서 측정한 것이다. 약 4초 동안 3분의 1에 해당되는 시간이 Javascript 연산을 실행하는데 사용되었다.\n\n![test2.png](/blog/images/window-open/test2.png)\n\n위의 결과를 통해 새로운 창을 열었을 때 부모 창과 메모리와 자원이 공유된다는 것을 확인할 수 있다.\n\n## noopener, noreferrer\n\n위의 두 가지 문제를 해결하기 위해 noopener 또는 noreferrer 속성을 사용할 수 있다. 두 개의 속성은 다음과 같은 특징이 있다.\n\n- noopener\n\nnoopener는 새 창이나 탭에서 Javascript를 사용하여 원래 페이지의 window객체에 접근하는 것을 막는다.\n\n- noreferrer\n\nnoreferrer는 새 창이나 탭에서 HTTP Referrer를 차단한다. 이를 통해 부모 페이지의 URL정보가 새 창에 전달되지 않는다.\n\n따라서 두 개의 속성을 다음과 같이 추가하면 부모 창과 새 창이 독립적인 메모리와 자원을 갖도록 할 수 있다.\n\n```jsx\nconst handleClick = () => {\n  window.open(\"https://www.google.com\", \"_blank\", \"noopener, noreferrer\");\n};\n```\n\n아래 그림은 noopener 속성을 추가한 상태에서 위와 같이 동일하게 테스트를 진행한 결과이다. 새 창을 열지 않았을 때와 동일하게 약 4초 동안 Javascript 연산에 극히 적은 시간이 사용되었다.\n\n![test3.png](/blog/images/window-open/test3.png)\n\n## 정리\n\n기본적으로 보안상 window.open을 사용하면 noopener와 noreferrer 속성이 설정된 상태로 새 창이 열린다. 하지만 width와 height가 설정된 상태로 새 창이 열리게되면 기본적으로 해당 속성이 추가되지 않기 때문에 반드시 추가해줘야한다.\n모니터링 관련 프로젝트를 진행하면서 혹시 많은 수를 모니터링할 때 성능에 문제가 있지 않을까?라는 생각으로 여러가지를 시도하면서 보안 이슈가 있었던 것도 알게되었고, 새 창이 부모 창과 자원을 공유한다는 것도 배울 수 있었다.\n"],"categoryList":["essay","javascript"]},"__N_SSG":true}