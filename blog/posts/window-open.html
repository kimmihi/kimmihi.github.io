<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/d78ec212a8df876c.css" as="style"/><link rel="stylesheet" href="/_next/static/css/d78ec212a8df876c.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-c4acd79e87956a0e.js" defer=""></script><script src="/_next/static/chunks/framework-5866cead997b9ace.js" defer=""></script><script src="/_next/static/chunks/main-edf2074a22277221.js" defer=""></script><script src="/_next/static/chunks/pages/_app-f97039bd48e0b753.js" defer=""></script><script src="/_next/static/chunks/9f96d65d-122a2632014666a3.js" defer=""></script><script src="/_next/static/chunks/378-f1f543076b020da3.js" defer=""></script><script src="/_next/static/chunks/42-c0b34bf3a66c6967.js" defer=""></script><script src="/_next/static/chunks/pages/blog/posts/%5Bid%5D-987cae7dda2909cd.js" defer=""></script><script src="/_next/static/jkIkjvqTRsDkfn5Yen7dR/_buildManifest.js" defer=""></script><script src="/_next/static/jkIkjvqTRsDkfn5Yen7dR/_ssgManifest.js" defer=""></script></head><body><div id="__next"><main><header style="padding:2rem 4vw;display:flex;align-items:center;justify-content:space-between"><h1 style="font-size:32px;font-weight:600;cursor:pointer" role="button">MHK</h1><div style="display:flex;align-items:center;justify-content:center"><button style="color:#4d4d4d;background-color:#f2f2f2;padding:8px;font-size:18px;border:none;border-bottom:none;font-weight:600;margin:0 32px;cursor:pointer">Blog</button><button style="color:#4d4d4d;background-color:#f2f2f2;padding:8px;font-size:18px;border:none;border-bottom:none;font-weight:600;margin:0 32px;cursor:pointer">About</button></div><style data-emotion="css 1wf493t">.css-1wf493t{text-align:center;-webkit-flex:0 0 auto;-ms-flex:0 0 auto;flex:0 0 auto;font-size:1.5rem;padding:8px;border-radius:50%;overflow:visible;color:rgba(0, 0, 0, 0.54);-webkit-transition:background-color 150ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:background-color 150ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;}.css-1wf493t:hover{background-color:rgba(0, 0, 0, 0.04);}@media (hover: none){.css-1wf493t:hover{background-color:transparent;}}.css-1wf493t.Mui-disabled{background-color:transparent;color:rgba(0, 0, 0, 0.26);}</style><style data-emotion="css 1yxmbwk">.css-1yxmbwk{display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;position:relative;box-sizing:border-box;-webkit-tap-highlight-color:transparent;background-color:transparent;outline:0;border:0;margin:0;border-radius:0;padding:0;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:middle;-moz-appearance:none;-webkit-appearance:none;-webkit-text-decoration:none;text-decoration:none;color:inherit;text-align:center;-webkit-flex:0 0 auto;-ms-flex:0 0 auto;flex:0 0 auto;font-size:1.5rem;padding:8px;border-radius:50%;overflow:visible;color:rgba(0, 0, 0, 0.54);-webkit-transition:background-color 150ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:background-color 150ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;}.css-1yxmbwk::-moz-focus-inner{border-style:none;}.css-1yxmbwk.Mui-disabled{pointer-events:none;cursor:default;}@media print{.css-1yxmbwk{-webkit-print-color-adjust:exact;color-adjust:exact;}}.css-1yxmbwk:hover{background-color:rgba(0, 0, 0, 0.04);}@media (hover: none){.css-1yxmbwk:hover{background-color:transparent;}}.css-1yxmbwk.Mui-disabled{background-color:transparent;color:rgba(0, 0, 0, 0.26);}</style><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-sizeMedium css-1yxmbwk" tabindex="0" type="button"><style data-emotion="css f40331">.css-f40331{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:1em;height:1em;display:inline-block;fill:currentColor;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;-webkit-transition:fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;font-size:1.5rem;font-size:32px;color:#262626;}</style><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium css-f40331" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="GitHubIcon"><path d="M12 1.27a11 11 0 00-3.48 21.46c.55.09.73-.28.73-.55v-1.84c-3.03.64-3.67-1.46-3.67-1.46-.55-1.29-1.28-1.65-1.28-1.65-.92-.65.1-.65.1-.65 1.1 0 1.73 1.1 1.73 1.1.92 1.65 2.57 1.2 3.21.92a2 2 0 01.64-1.47c-2.47-.27-5.04-1.19-5.04-5.5 0-1.1.46-2.1 1.2-2.84a3.76 3.76 0 010-2.93s.91-.28 3.11 1.1c1.8-.49 3.7-.49 5.5 0 2.1-1.38 3.02-1.1 3.02-1.1a3.76 3.76 0 010 2.93c.83.74 1.2 1.74 1.2 2.94 0 4.21-2.57 5.13-5.04 5.4.45.37.82.92.82 2.02v3.03c0 .27.1.64.73.55A11 11 0 0012 1.27"></path></svg></button></header><main style="margin:0 10vw"><article style="margin:0 5vw;padding:5vw 0"><h1 style="color:#4d4d4d;margin:1rem 0;font-weight:600;font-size:clamp(1.75rem, 1.39rem + 1.79vw, 2.6rem)">window.open을 사용할 때 알아두면 좋은 점</h1>
<h1 style="margin:1rem 0;font-weight:500;font-size:clamp(1.5rem, 1.29rem + 1.07vw, 2rem)">Intro</h1>
<p style="display:block;line-height:2rem;color:#4d4d4d;font-size:clamp(1rem, 0.96rem + 10vw, 1.125rem);margin-bottom:2rem"><strong>window.open</strong>을 사용하면 해당 메서드를 호출한 페이지에서 새로운 창 또는 탭이 열리도록 할 수 있다. 최근에 모니터링 관련 기능을 개발하면서 새로운 창을 100개 이상 열어야했고, 새로운 창에서는 WebSocket을 통한 통신이 이루어졌다. 이때 100개 이상 열었을 때 성능에는 문제가 없는지 궁금해서 테스트를 해봤고 새로운 사실을 알 수 있었다. 그래서 이번에 <strong>window.open</strong>을 사용할 때 알아두면 좋은 점을 정리해보려고 한다.</p>
<h1 style="margin:1rem 0;font-weight:500;font-size:clamp(1.5rem, 1.29rem + 1.07vw, 2rem)">window.open()은 어떻게 사용할까?</h1>
<p style="display:block;line-height:2rem;color:#4d4d4d;font-size:clamp(1rem, 0.96rem + 10vw, 1.125rem);margin-bottom:2rem">window.open()은 다음 예시 코드처럼 간단하게 사용할 수 있으며 3개의 파라미터를 전달할 수 있다. 첫 번째 파라미터에 URL을 전달하면 해당 URL이 새 탭으로 열리게 된다.</p>
<pre><pre style="display:block;overflow-x:auto;padding:24px;background:#1E1E1E;color:#DCDCDC;border-radius:12px"><code class="language-jsx" style="white-space:pre"><span>const handleClick = </span><span style="color:#DCDCDC">()</span><span style="color:#DCDCDC"> =&gt;</span><span> {
</span><span>  </span><span style="color:#4EC9B0">window</span><span>.open(</span><span style="color:#D69D85">&quot;https://www.google.com&quot;</span><span>);
</span>};
</code></pre></pre>
<p style="display:block;line-height:2rem;color:#4d4d4d;font-size:clamp(1rem, 0.96rem + 10vw, 1.125rem);margin-bottom:2rem">또한 두 번째 파라미터인 target을 통해 새 창이 열릴 위치를 지정할 수 있다.</p>
<ul>
<li style="display:list-item;margin:16px 0;font-size:clamp(1rem, 0.96rem + 10vw, 1.125rem)">_blank : 링크가 새 창에서 열린다.</li>
<li style="display:list-item;margin:16px 0;font-size:clamp(1rem, 0.96rem + 10vw, 1.125rem)">_self : 링크가 현재 창에서 열린다.</li>
<li style="display:list-item;margin:16px 0;font-size:clamp(1rem, 0.96rem + 10vw, 1.125rem)">_parent : 링크가 부모 창에서 열린다.</li>
<li style="display:list-item;margin:16px 0;font-size:clamp(1rem, 0.96rem + 10vw, 1.125rem)">_top : 링크가 최상위 창에서 열린다.</li>
</ul>
<p style="display:block;line-height:2rem;color:#4d4d4d;font-size:clamp(1rem, 0.96rem + 10vw, 1.125rem);margin-bottom:2rem">마지막으로 세 번째 파라미터에는 스타일 등의 속성을 문자열로 전달할 수 있다.</p>
<h1 style="margin:1rem 0;font-weight:500;font-size:clamp(1.5rem, 1.29rem + 1.07vw, 2rem)">window.open()을 사용할 때 주의할 점</h1>
<p style="display:block;line-height:2rem;color:#4d4d4d;font-size:clamp(1rem, 0.96rem + 10vw, 1.125rem);margin-bottom:2rem">먼저 첫 번째로 <strong>Tabnabbing</strong> 공격을 방어해야 한다. Tabnabbing 공격은 다음 순서로 진행된다.</p>
<ol>
<li style="display:list-item;margin:16px 0;font-size:clamp(1rem, 0.96rem + 10vw, 1.125rem)">A라는 페이지에 접속</li>
<li style="display:list-item;margin:16px 0;font-size:clamp(1rem, 0.96rem + 10vw, 1.125rem)">해당 페이지에서 새로운 페이지로 이동할 수 있는 외부링크 클릭</li>
<li style="display:list-item;margin:16px 0;font-size:clamp(1rem, 0.96rem + 10vw, 1.125rem)">새로운 페이지에서 기존 A페이지를 가리키는 opener로 기존 A페이지를 다른 페이지로 유도</li>
<li style="display:list-item;margin:16px 0;font-size:clamp(1rem, 0.96rem + 10vw, 1.125rem)">A페이지에 돌아왔을 때 사용자가 입력한 정보에 대해 피싱</li>
</ol>
<p style="display:block;line-height:2rem;color:#4d4d4d;font-size:clamp(1rem, 0.96rem + 10vw, 1.125rem);margin-bottom:2rem">하지만 위의 문제는 2016년부터 크롬에서 window.open()을 _blank로 열 때, 새 페이지에서 opener를 갖지못하도록 속성이 설정되어있어서 방어가 가능하다.</p>
<p style="display:block;line-height:2rem;color:#4d4d4d;font-size:clamp(1rem, 0.96rem + 10vw, 1.125rem);margin-bottom:2rem">두 번째 문제는 이 글을 쓰는 이유에 있는데 <strong>같은 도메인의 다른 페이지를 새 창으로 열었을 때, 새 창과 부모 창의 메모리와 자원이 공유된다는 것이다.</strong> 그렇기 때문에 부모 창과 새 창에서 높은 수준의 연산이 필요한 작업을 한다면 성능이 떨어질 수 있다.</p>
<p style="display:block;line-height:2rem;color:#4d4d4d;font-size:clamp(1rem, 0.96rem + 10vw, 1.125rem);margin-bottom:2rem">이를 알아보기 위한 간단한 테스트를 준비했다. 페이지 내에서 10ms마다 랜덤한 숫자를 출력한다. 그리고 새롭게 열린 창에서도 10ms마다 랜덤한 숫자를 출력하도록 하였다. 이를 크롬의 Performance로 측정하였다.</p>
<p style="display:block;line-height:2rem;color:#4d4d4d;font-size:clamp(1rem, 0.96rem + 10vw, 1.125rem);margin-bottom:2rem">먼저 아래의 사진은 새 창을 열지 않았을 때의 결과이다. 약 4초 동안 Javascript 연산을 실행하는데 극히 적은 시간을 사용했다.</p>
<p style="display:block;line-height:2rem;color:#4d4d4d;font-size:clamp(1rem, 0.96rem + 10vw, 1.125rem);margin-bottom:2rem"><div style="display:flex;justify-content:center;position:relative;width:100%;height:300px"><img alt="test1.png" loading="lazy" decoding="async" data-nimg="fill" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;object-fit:contain;object-position:center;color:transparent" sizes="100vw" srcSet="https://kimmihi.github.io/?url=%2Fblog%2Fimages%2Fwindow-open%2Ftest1.png&amp;w=640&amp;q=75 640w, https://kimmihi.github.io/?url=%2Fblog%2Fimages%2Fwindow-open%2Ftest1.png&amp;w=750&amp;q=75 750w, https://kimmihi.github.io/?url=%2Fblog%2Fimages%2Fwindow-open%2Ftest1.png&amp;w=828&amp;q=75 828w, https://kimmihi.github.io/?url=%2Fblog%2Fimages%2Fwindow-open%2Ftest1.png&amp;w=1080&amp;q=75 1080w, https://kimmihi.github.io/?url=%2Fblog%2Fimages%2Fwindow-open%2Ftest1.png&amp;w=1200&amp;q=75 1200w, https://kimmihi.github.io/?url=%2Fblog%2Fimages%2Fwindow-open%2Ftest1.png&amp;w=1920&amp;q=75 1920w, https://kimmihi.github.io/?url=%2Fblog%2Fimages%2Fwindow-open%2Ftest1.png&amp;w=2048&amp;q=75 2048w, https://kimmihi.github.io/?url=%2Fblog%2Fimages%2Fwindow-open%2Ftest1.png&amp;w=3840&amp;q=75 3840w" src="https://kimmihi.github.io/?url=%2Fblog%2Fimages%2Fwindow-open%2Ftest1.png&amp;w=3840&amp;q=75"/></div></p>
<p style="display:block;line-height:2rem;color:#4d4d4d;font-size:clamp(1rem, 0.96rem + 10vw, 1.125rem);margin-bottom:2rem">반면 아래의 결과는 새로운 창 10개를 열고 부모 창에서 측정한 것이다. 약 4초 동안 3분의 1에 해당되는 시간이 Javascript 연산을 실행하는데 사용되었다.</p>
<p style="display:block;line-height:2rem;color:#4d4d4d;font-size:clamp(1rem, 0.96rem + 10vw, 1.125rem);margin-bottom:2rem"><div style="display:flex;justify-content:center;position:relative;width:100%;height:300px"><img alt="test2.png" loading="lazy" decoding="async" data-nimg="fill" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;object-fit:contain;object-position:center;color:transparent" sizes="100vw" srcSet="https://kimmihi.github.io/?url=%2Fblog%2Fimages%2Fwindow-open%2Ftest2.png&amp;w=640&amp;q=75 640w, https://kimmihi.github.io/?url=%2Fblog%2Fimages%2Fwindow-open%2Ftest2.png&amp;w=750&amp;q=75 750w, https://kimmihi.github.io/?url=%2Fblog%2Fimages%2Fwindow-open%2Ftest2.png&amp;w=828&amp;q=75 828w, https://kimmihi.github.io/?url=%2Fblog%2Fimages%2Fwindow-open%2Ftest2.png&amp;w=1080&amp;q=75 1080w, https://kimmihi.github.io/?url=%2Fblog%2Fimages%2Fwindow-open%2Ftest2.png&amp;w=1200&amp;q=75 1200w, https://kimmihi.github.io/?url=%2Fblog%2Fimages%2Fwindow-open%2Ftest2.png&amp;w=1920&amp;q=75 1920w, https://kimmihi.github.io/?url=%2Fblog%2Fimages%2Fwindow-open%2Ftest2.png&amp;w=2048&amp;q=75 2048w, https://kimmihi.github.io/?url=%2Fblog%2Fimages%2Fwindow-open%2Ftest2.png&amp;w=3840&amp;q=75 3840w" src="https://kimmihi.github.io/?url=%2Fblog%2Fimages%2Fwindow-open%2Ftest2.png&amp;w=3840&amp;q=75"/></div></p>
<p style="display:block;line-height:2rem;color:#4d4d4d;font-size:clamp(1rem, 0.96rem + 10vw, 1.125rem);margin-bottom:2rem">위의 결과를 통해 새로운 창을 열었을 때 부모 창과 메모리와 자원이 공유된다는 것을 확인할 수 있다.</p>
<h1 style="margin:1rem 0;font-weight:500;font-size:clamp(1.5rem, 1.29rem + 1.07vw, 2rem)">noopener, noreferrer</h1>
<p style="display:block;line-height:2rem;color:#4d4d4d;font-size:clamp(1rem, 0.96rem + 10vw, 1.125rem);margin-bottom:2rem">위의 두 가지 문제를 해결하기 위해 noopener 또는 noreferrer 속성을 사용할 수 있다. 두 개의 속성은 다음과 같은 특징이 있다.</p>
<ul>
<li style="display:list-item;margin:16px 0;font-size:clamp(1rem, 0.96rem + 10vw, 1.125rem)">noopener</li>
</ul>
<p style="display:block;line-height:2rem;color:#4d4d4d;font-size:clamp(1rem, 0.96rem + 10vw, 1.125rem);margin-bottom:2rem">noopener는 새 창이나 탭에서 Javascript를 사용하여 원래 페이지의 window객체에 접근하는 것을 막는다.</p>
<ul>
<li style="display:list-item;margin:16px 0;font-size:clamp(1rem, 0.96rem + 10vw, 1.125rem)">noreferrer</li>
</ul>
<p style="display:block;line-height:2rem;color:#4d4d4d;font-size:clamp(1rem, 0.96rem + 10vw, 1.125rem);margin-bottom:2rem">noreferrer는 새 창이나 탭에서 HTTP Referrer를 차단한다. 이를 통해 부모 페이지의 URL정보가 새 창에 전달되지 않는다.</p>
<p style="display:block;line-height:2rem;color:#4d4d4d;font-size:clamp(1rem, 0.96rem + 10vw, 1.125rem);margin-bottom:2rem">따라서 두 개의 속성을 다음과 같이 추가하면 부모 창과 새 창이 독립적인 메모리와 자원을 갖도록 할 수 있다.</p>
<pre><pre style="display:block;overflow-x:auto;padding:24px;background:#1E1E1E;color:#DCDCDC;border-radius:12px"><code class="language-jsx" style="white-space:pre"><span>const handleClick = </span><span style="color:#DCDCDC">()</span><span style="color:#DCDCDC"> =&gt;</span><span> {
</span><span>  </span><span style="color:#4EC9B0">window</span><span>.open(</span><span style="color:#D69D85">&quot;https://www.google.com&quot;</span><span>, </span><span style="color:#D69D85">&quot;_blank&quot;</span><span>, </span><span style="color:#D69D85">&quot;noopener, noreferrer&quot;</span><span>);
</span>};
</code></pre></pre>
<p style="display:block;line-height:2rem;color:#4d4d4d;font-size:clamp(1rem, 0.96rem + 10vw, 1.125rem);margin-bottom:2rem">아래 그림은 noopener 속성을 추가한 상태에서 위와 같이 동일하게 테스트를 진행한 결과이다. 새 창을 열지 않았을 때와 동일하게 약 4초 동안 Javascript 연산에 극히 적은 시간이 사용되었다.</p>
<p style="display:block;line-height:2rem;color:#4d4d4d;font-size:clamp(1rem, 0.96rem + 10vw, 1.125rem);margin-bottom:2rem"><div style="display:flex;justify-content:center;position:relative;width:100%;height:300px"><img alt="test3.png" loading="lazy" decoding="async" data-nimg="fill" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;object-fit:contain;object-position:center;color:transparent" sizes="100vw" srcSet="https://kimmihi.github.io/?url=%2Fblog%2Fimages%2Fwindow-open%2Ftest3.png&amp;w=640&amp;q=75 640w, https://kimmihi.github.io/?url=%2Fblog%2Fimages%2Fwindow-open%2Ftest3.png&amp;w=750&amp;q=75 750w, https://kimmihi.github.io/?url=%2Fblog%2Fimages%2Fwindow-open%2Ftest3.png&amp;w=828&amp;q=75 828w, https://kimmihi.github.io/?url=%2Fblog%2Fimages%2Fwindow-open%2Ftest3.png&amp;w=1080&amp;q=75 1080w, https://kimmihi.github.io/?url=%2Fblog%2Fimages%2Fwindow-open%2Ftest3.png&amp;w=1200&amp;q=75 1200w, https://kimmihi.github.io/?url=%2Fblog%2Fimages%2Fwindow-open%2Ftest3.png&amp;w=1920&amp;q=75 1920w, https://kimmihi.github.io/?url=%2Fblog%2Fimages%2Fwindow-open%2Ftest3.png&amp;w=2048&amp;q=75 2048w, https://kimmihi.github.io/?url=%2Fblog%2Fimages%2Fwindow-open%2Ftest3.png&amp;w=3840&amp;q=75 3840w" src="https://kimmihi.github.io/?url=%2Fblog%2Fimages%2Fwindow-open%2Ftest3.png&amp;w=3840&amp;q=75"/></div></p>
<h1 style="margin:1rem 0;font-weight:500;font-size:clamp(1.5rem, 1.29rem + 1.07vw, 2rem)">정리</h1>
<p style="display:block;line-height:2rem;color:#4d4d4d;font-size:clamp(1rem, 0.96rem + 10vw, 1.125rem);margin-bottom:2rem">기본적으로 보안상 window.open을 사용하면 noopener와 noreferrer 속성이 설정된 상태로 새 창이 열린다. 하지만 width와 height가 설정된 상태로 새 창이 열리게되면 기본적으로 해당 속성이 추가되지 않기 때문에 반드시 추가해줘야한다.
모니터링 관련 프로젝트를 진행하면서 혹시 많은 수를 모니터링할 때 성능에 문제가 있지 않을까?라는 생각으로 여러가지를 시도하면서 보안 이슈가 있었던 것도 알게되었고, 새 창이 부모 창과 자원을 공유한다는 것도 배울 수 있었다.</p></article></main></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"matterPost":"---\nid: window-open\ntitle: window.open을 사용할 때 알아두면 좋은 점\ndate: 2023-04-20\ncategory: javascript\nthumb_nail: /blog/images/window-open/test2.png\nsummary: 여러 개의 창을 열어 모니터링을 할 수 있도록 window.open을 사용하였다. 이때 몇 가지 문제가 있다는 것을 발견하였고 이를 해결하기 위한 방법을 정리하였다.\n---\n\n# window.open을 사용할 때 알아두면 좋은 점\n\n## Intro\n\n**window.open**을 사용하면 해당 메서드를 호출한 페이지에서 새로운 창 또는 탭이 열리도록 할 수 있다. 최근에 모니터링 관련 기능을 개발하면서 새로운 창을 100개 이상 열어야했고, 새로운 창에서는 WebSocket을 통한 통신이 이루어졌다. 이때 100개 이상 열었을 때 성능에는 문제가 없는지 궁금해서 테스트를 해봤고 새로운 사실을 알 수 있었다. 그래서 이번에 **window.open**을 사용할 때 알아두면 좋은 점을 정리해보려고 한다.\n\n## window.open()은 어떻게 사용할까?\n\nwindow.open()은 다음 예시 코드처럼 간단하게 사용할 수 있으며 3개의 파라미터를 전달할 수 있다. 첫 번째 파라미터에 URL을 전달하면 해당 URL이 새 탭으로 열리게 된다.\n\n```jsx\nconst handleClick = () =\u003e {\n  window.open(\"https://www.google.com\");\n};\n```\n\n또한 두 번째 파라미터인 target을 통해 새 창이 열릴 위치를 지정할 수 있다.\n\n- \\_blank : 링크가 새 창에서 열린다.\n- \\_self : 링크가 현재 창에서 열린다.\n- \\_parent : 링크가 부모 창에서 열린다.\n- \\_top : 링크가 최상위 창에서 열린다.\n\n마지막으로 세 번째 파라미터에는 스타일 등의 속성을 문자열로 전달할 수 있다.\n\n## window.open()을 사용할 때 주의할 점\n\n먼저 첫 번째로 **Tabnabbing** 공격을 방어해야 한다. Tabnabbing 공격은 다음 순서로 진행된다.\n\n1. A라는 페이지에 접속\n2. 해당 페이지에서 새로운 페이지로 이동할 수 있는 외부링크 클릭\n3. 새로운 페이지에서 기존 A페이지를 가리키는 opener로 기존 A페이지를 다른 페이지로 유도\n4. A페이지에 돌아왔을 때 사용자가 입력한 정보에 대해 피싱\n\n하지만 위의 문제는 2016년부터 크롬에서 window.open()을 \\_blank로 열 때, 새 페이지에서 opener를 갖지못하도록 속성이 설정되어있어서 방어가 가능하다.\n\n두 번째 문제는 이 글을 쓰는 이유에 있는데 **같은 도메인의 다른 페이지를 새 창으로 열었을 때, 새 창과 부모 창의 메모리와 자원이 공유된다는 것이다.** 그렇기 때문에 부모 창과 새 창에서 높은 수준의 연산이 필요한 작업을 한다면 성능이 떨어질 수 있다.\n\n이를 알아보기 위한 간단한 테스트를 준비했다. 페이지 내에서 10ms마다 랜덤한 숫자를 출력한다. 그리고 새롭게 열린 창에서도 10ms마다 랜덤한 숫자를 출력하도록 하였다. 이를 크롬의 Performance로 측정하였다.\n\n먼저 아래의 사진은 새 창을 열지 않았을 때의 결과이다. 약 4초 동안 Javascript 연산을 실행하는데 극히 적은 시간을 사용했다.\n\n![test1.png](/blog/images/window-open/test1.png)\n\n반면 아래의 결과는 새로운 창 10개를 열고 부모 창에서 측정한 것이다. 약 4초 동안 3분의 1에 해당되는 시간이 Javascript 연산을 실행하는데 사용되었다.\n\n![test2.png](/blog/images/window-open/test2.png)\n\n위의 결과를 통해 새로운 창을 열었을 때 부모 창과 메모리와 자원이 공유된다는 것을 확인할 수 있다.\n\n## noopener, noreferrer\n\n위의 두 가지 문제를 해결하기 위해 noopener 또는 noreferrer 속성을 사용할 수 있다. 두 개의 속성은 다음과 같은 특징이 있다.\n\n- noopener\n\nnoopener는 새 창이나 탭에서 Javascript를 사용하여 원래 페이지의 window객체에 접근하는 것을 막는다.\n\n- noreferrer\n\nnoreferrer는 새 창이나 탭에서 HTTP Referrer를 차단한다. 이를 통해 부모 페이지의 URL정보가 새 창에 전달되지 않는다.\n\n따라서 두 개의 속성을 다음과 같이 추가하면 부모 창과 새 창이 독립적인 메모리와 자원을 갖도록 할 수 있다.\n\n```jsx\nconst handleClick = () =\u003e {\n  window.open(\"https://www.google.com\", \"_blank\", \"noopener, noreferrer\");\n};\n```\n\n아래 그림은 noopener 속성을 추가한 상태에서 위와 같이 동일하게 테스트를 진행한 결과이다. 새 창을 열지 않았을 때와 동일하게 약 4초 동안 Javascript 연산에 극히 적은 시간이 사용되었다.\n\n![test3.png](/blog/images/window-open/test3.png)\n\n## 정리\n\n기본적으로 보안상 window.open을 사용하면 noopener와 noreferrer 속성이 설정된 상태로 새 창이 열린다. 하지만 width와 height가 설정된 상태로 새 창이 열리게되면 기본적으로 해당 속성이 추가되지 않기 때문에 반드시 추가해줘야한다.\n모니터링 관련 프로젝트를 진행하면서 혹시 많은 수를 모니터링할 때 성능에 문제가 있지 않을까?라는 생각으로 여러가지를 시도하면서 보안 이슈가 있었던 것도 알게되었고, 새 창이 부모 창과 자원을 공유한다는 것도 배울 수 있었다.\n"},"__N_SSG":true},"page":"/blog/posts/[id]","query":{"id":"window-open"},"buildId":"jkIkjvqTRsDkfn5Yen7dR","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>