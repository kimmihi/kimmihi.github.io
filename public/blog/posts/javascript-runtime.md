---
id: javascript-runtime
title: 브라우저는 자바스크립트를 어떻게 실행시킬까?
date: 2023-04-02
category: javascript
thumb_nail: /blog/images/javascript-runtime/thumb_nail.png
summary: 프로그래밍 언어를 공부할 때 그 언어가 어떻게 실행되고, 어디에 주로 쓰이는지 등과 같은 특성을 아는 것은 언어를 깊이 이해하는 데에 도움이 된다고 생각한다. 그래서 이번에 자바스크립트의 런타임 환경에 대해 정리를 하였다. 자바스크립트는 크롬, 엣지, 사파리와 같은 웹 브라우저에서 실행되는데 각각의 웹 브라우저에는 자바스크립트를 실행시키기 위한 엔진이 존재한다. 그 중에서 크롬의 자바스크립트 엔진인 V8을 기준으로 정리하려고 한다. 왜냐하면 크롬이라는 웹 브라우저를 가장 많이 사용하기도 하지만 자바스크립트를 서버 사이드에서 사용할 수 있도록 Node.js에서 V8 엔진을 사용하고 있기 때문이다. 이 글에는 자바스크립트가 어떤 과정과 방법을 통해 실행이되는지 알아보고, 이를 통해 실제 자바스크립트로 좋은 코드를 작성하기 위해서는 어떻게 할 수 있을지 아이디어를 얻어보고자 한다.
---

# 브라우저는 자바스크립트를 어떻게 실행시킬까?

## Intro

프로그래밍 언어를 공부할 때 그 언어가 어떻게 실행되고, 어디에 주로 쓰이는지 등과 같은 특성을 아는 것은 언어를 깊이 이해하는 데에 도움이 된다고 생각한다. 그래서 이번에 자바스크립트의 런타임 환경에 대해 정리를 하였다.

자바스크립트는 크롬, 엣지, 사파리와 같은 웹 브라우저에서 실행되는데 각각의 웹 브라우저에는 자바스크립트를 실행시키기 위한 엔진이 존재한다. 그 중에서 크롬의 자바스크립트 엔진인 V8을 기준으로 정리하려고 한다. 왜냐하면 크롬이라는 웹 브라우저를 가장 많이 사용하기도 하지만 자바스크립트를 서버 사이드에서 사용할 수 있도록 Node.js에서 V8 엔진을 사용하고 있기 때문이다.

이 글에는 자바스크립트가 어떤 과정과 방법을 통해 실행이되는지 알아보고, 이를 통해 실제 자바스크립트로 좋은 코드를 작성하기 위해서는 어떻게 할 수 있을지 아이디어를 얻어보고자 한다.

## Javascript가 실행되는 환경

브라우저에서 자바스크립트를 어떻게 실행시키는지 알기 위해서는 런타임 환경이라는 단어의 의미를 간단히 알아둘 필요가 있다. 런타임 환경은 어떤 프로그래밍 언어가 실행되는 환경을 의미한다. 자바스크립트의 런타임 환경은 주로 브라우저이며 브라우저의 자바스크립트 엔진을 통해 자바스크립트 코드가 실행된다. 또한, Chrome의 자바스크립트 엔진인 V8으로 빌드된 Node.js를 활용하면 서버 측에서도 자바스크립트 코드를 실행시킬 수 있다.

## Chrome의 자바스크립트 엔진 : V8

Chrome의 V8은 구글에서 개발한 자바스크립트 엔진이며 Node.js에서도 이 엔진을 사용하여 서버 측에서도 자바스크립트를 실행시킬 수 있게 되었다. 아래의 그림은 V8이 어떻게 자바스크립트 코드를 해석하여 실행시키는지 파악할 수 있는 흐름을 나타내고 있다.

![v8.png](/blog/images/javascript-runtime/v8.png)

각각의 단계에서 어떤 일들이 발생하는지 알아보자.

### 1. 구문 분석 (Parsing)

먼저 자바스크립트 코드는 Parser를 통해 토큰으로 분해되고 이를 추상 구문 트리(AST)로 변환한다. 추상 구문 트리는 소스 코드를 계층적으로 분해하여 인터프리터가 읽어드리기 쉽게 해준다. 예를 들어 아래의 두 개의 숫자를 전달받아 더한 값을 반환하는 함수와 그 함수를 실행시키는 코드가 있다고 해보자.

```javascript
function sum(a, b) {
  return a + b;
}

sum(3, 5);
```

위의 코드를 추상 구문 트리로 변환하면 아래와 비슷한 형태로 변환될 것이다.

```scss
Program
└─ FunctionDeclaration (sum)
   ├─ Identifier (a)
   ├─ Identifier (b)
   └─ BinaryExpression (+)
      ├─ Identifier (a)
      └─ Identifier (b)
```

그런데 왜 추상 구문 트리로 변환하는 것일까? 여기에는 다양한 이유가 있지만 크게 3가지 이유는 다음과 같다.

1. 기계어로 컴파일 하기 전에 코드를 분석하고 최적화할 수 있는 부분을 미리 찾아낼 수 있다.
2. 코드를 직관적으로 표현하기 때문에 잠재적인 보안 취약점을 식별하고 예방할 수 있다.
3. 자바스크립트 코드를 바이트 코드로 변환하는 것보다 추상 구문 트리를 바이트 코드로 변환하는 것이 더 빠르다.

### 2. 인터프리터 : Ignition

자바스크립트는 인터프리터에 의해 실행된다. 인터프리터는 소스 코드를 한줄 한줄 해석한 후에 실행시키는 프로그램을 의미한다. 반면에 컴파일러는 실행시키기 전에 소스 코드를 해석하여 실행할 수 있는 파일을 만들어내는 프로그램이다.

V8 엔진은 Ignition이라는 인터프리터를 사용한다. Ignition은 Parser에 의해 생성된 추상 구문 트리를 해석하여 컴퓨터에 명령을 내릴 수 있는 바이트 코드를 생성한다.

### 3. 최적화 : Turbofan

인터프리터를 사용하는 언어는 컴파일러를 사용하는 언어보다 실행속도가 느리다는 단점이 있다. 미리 기계 코드로 변환된 것을 실행시키는 컴파일러 언어보다 매번 소스 코드를 해석하고 실행시키기 때문이다. 하지만 V8 엔진에는 이러한 단점을 보완하는 Turbofan이라는 컴포넌트가 존재한다. 이번에는 Turbofan이 인터프리터 언어의 단점을 보완하기 위해 최적화하는 방법 3가지를 알아보려고 한다.

1. **인라이닝**

인라이닝에 대해 알아보기 전에 함수를 호출할 때 무슨 일이 발생하는지 간단하게 알아둘 필요가 있다. 함수를 호출하면 함수가 실행이 완료되고 다시 함수를 호출한 위치로 돌아가기 위한 주소를 저장한다. 그리고 함수가 콜 스택에 추가되어 실행을 기다린다. 이렇게 함수의 호출에는 비용이 발생한다. 이러한 비용을 줄이기 위해 인라이닝을 사용할 수 있다.

C/C++ 언어에는 인라인 함수가 존재한다. 함수를 호출하는 대신에 함수의 로직을 함수를 호출한 부분에 삽입시키는 것이다. 아래의 코드를 보자. **min** 함수는 두 개의 숫자를 전달받아 작은 수를 반환하는 함수이다. 이를 반복문을 통해 1000번 호출하고 있다. 함수를 호출할 때마다 오버헤드가 발생할 것 같지만 **inline** 이라는 키워드를 통해 생성된 인라인 함수는 주석에 표시한 것처럼 함수 안의 로직이 함수를 호출한 부분에 삽입되어 오버헤드가 발생하지 않는다.

```cpp
inline int min(int a, int b) {
	return a <= b ? a : b;
}

void main() {
	int x = 5;

	for (int i = 0; i < 1000; i++) {
		int min_num = (x, i); // int min_num = x <= i ? : x : i;
		printf("%d", min_num);
	}

}
```

이처럼 Turbofan에서도 인라이닝을 통해 코드를 최적화하고 있다. 하지만 모든 함수에 대해 인라이닝을 적용하는 것은 아니다. 함수의 로직을 함수를 호출한 모든 부분에 삽입한다면 코드가 길어지고 메모리를 많이 사용하게 된다. 따라서 간단하고 적은 코드를 포함한 함수에 대해서만 인라이닝을 적용한다.

1. **히든 클래스**

자밥스크립트는 동적인 언어다. 실행 중에도 객체에 속성을 추가, 수정, 삭제를 할 수 있다. 이렇게 객체의 속성을 변경하기 위해서는 이미 존재하는 속성인지, 삭제하려는 속성은 무엇인지 탐색해야한다. 정적인 언어의 경우에는 컴파일 과정을 통해 미리 객체 안의 속성에 대한 오프셋을 알고있어 객체의 속성에 접근하는 것에 대한 오버헤드가 적다.

Turbofan에서는 히든 클래스를 통해 동적인 언어에 대한 단점을 보완하고 있다. 아래의 코드를 보자. **person** 이라는 객체를 생성하면 C01이라는 히든 클래스가 생성된다.

```javascript
const person = {}; // C01이라는 히든 클래스 생성
```

그 다음 **person** 객체에 **name** 이라는 속성을 추가하면 **name** 이라는 속성에 대한 오프셋을 저장하는 C02라는 히든 클래스를 생성한다. 이때 C01이라는 히든 클래스에는 **name** 이라는 속성을 추가하면 C02 히든 클래스로 전환된다는 정보가 추가된다.

```javascript
person.name = "Alex"; // C02이라는 히든 클래스 생성 { offset 0 : name }
```

여기서 **animal** 이라는 빈 객체를 생성하면 히든 클래스 C01을 가리킨다. 하지만 **animal** 에 **age** 라는 속성을 추가하면 이전에 생성한 히든 클래스 C02를 사용하지 않고 새로운 히든 클래스를 생성하게 된다.

1. **인라인 캐싱**

위에서 알아본 히든 클래스를 기반으로 인라인 캐싱이라는 최적화 기법이 사용된다. 객체의 속성에 접근할 때 오프셋을 캐싱하여 사용하겠다는 것이다. 아래의 코드를 보자. `name` 속성을 갖는 똑같은 구조의 객체가 있다. 해당 속성에 접근을 할 때 처음에는 캐싱된 값이 없기 때문에 히든 클래스와 오프셋 값을 찾아서 저장한다. 이후에 속성 접근을 할 때는 캐싱된 값을 사용하여 더 빠르게 접근할 수 있게된다.

```javascript
const a = { name: "a" };
const b = { name: "b" };
const c = { name: "c" };
const d = { name: "d" };

const alphabet = [a, b, c, d];

for (let i = 0; i < alphabet.length; i++) {
  console.log(alphabet[i].name);
}
```

## 조금 더 나은 코드를 위해서 적용할 수 있는 방법

지금까지 V8 엔진에 대해서 알아봤다. 특히 Turbofan에서는 자바스크립트의 성능을 위해서 다양한 최적화 기법을 적용시켰는데 이를 이해하면 우리는 조금 더 성능이 좋은 코드를 작성할 수 있다. (개인적인 생각으로 틀린 내용이 있을 수 있습니다.)

첫 번째 방법은 객체의 속성을 동적으로 변경하지 않는 것이다. 특히, 반복문 내에서 객체의 속성을 추가/수정/변경을 하면 히든 클래스를 활용하지 못하여 속성을 탐색하는데 비효율적이다. 따라서 반복문 외부에서 객체를 정의한 후에 사용해야 한다.

두 번째 방법은 함수의 크기를 최소화하는 것이다. 작은 함수에 대해서 인라이닝을 적용하고 함수를 실행하는데 오버헤드가 적기 때문이다. 또한 함수의 크기를 최소화하는 것은 코드의 가독성을 높이고 하나의 함수를 한 가지 기능만을 하도록 만들 수 있다.

세 번째 방법은 함수를 재사용하는 것이다. 본문에서 언급하지는 않았지만 Turbofan은 자주 사용하는 코드를 기계 코드로 변환하여 실행한다. 아무래도 바이트 코드보다 기계 코드를 실행하는 것이 빠르다. 따라서 동일한 로직이 여러 번 사용된다면 함수를 만들어 사용하는 것이 효율적인 것 같다.

## 마무리

저번에 회사의 시니어 개발자와 대화를 나누다가 주니어 때는 한 가지 기술을 파고들되 다양한 경험을 얕게 해보는 것이 중요하다는 얘기를 들었다. 이를 간단히 T자형으로 성장한다고 말한다. 그러면서 현재 쓰고있는 기술 중에 스스로 잘 안다고 자신있게 말할 수 있는 것이 있을까?라는 생각을 했고 “없다”라는 결론이 나왔다.

그래서 자바스크립트에 대해 조금 더 깊게 공부를 해야되겠다는 생각을 하였고, 가장 먼저 자바스크립트가 어떻게 실행되는지 공부하고 정리를 하였다. 이에 대해 몰랐을 때보다 알고난 후에(모든 것을 아는 것은 아니지만) 자바스크립트에 대해 더 관심이 생겼고 코드를 작성할 때 “그냥” 작성하는 경우가 줄었다. 그래서 앞으로도 자바스크립트에 대해 조금 더 깊은 내용들을 공부하고 정리하려고 한다.
